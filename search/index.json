[{"content":"JDBC-进阶 1.实体类与ORM 在使用JDBC操作数据库时，会发现数据库里面的数据是零散的，明明在数据库中是一行完整的数据，到了java中变成了一个一个的变量，不利于维护和管理，而java是面向对象的，一个表对应一个类，一行数据对应java中一个对象，一个列对应的是对象的属性，所以要把数据存储在一个载体里，这个载体是实体类。\nORM(Object Relational Mapping)思想，对象到关系数据库的映射，作用是在编程中，把面向对象的概念跟数据库中表的概念对应起来，以面向对象的角度操作数据库中的数据，即一张表对应一个类，一行数据对应一个对象，一个列对应一个属性\nJDBC的过程称为手动ORM。\n1 2 3 4 5 6 7 8 9 10 11 package com.Chiba.advanced.pojo; //类名对应的是数据库t_后面的单词全写。 public class Employee { private int empId; private String empName; private double empSalary; private Integer empAge; //此处写get、set、无参、有参、toString方法 } 封装代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package com.Chiba.advanced; import com.Chiba.advanced.pojo.Employee; import org.junit.Test; import java.sql.*; import java.util.ArrayList; import java.util.List; public class JDBCAdvanced { @Test public void testORM() throws Exception { //passowrd修改为mysql设置的密码 Connection connection = DriverManager.getConnection(\u0026#34;jdbc:mysql:///jdbcdemo\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;password\u0026#34;); PreparedStatement preparedStatement = connection.prepareStatement(\u0026#34;select emp_id,emp_name,emp_salary,emp_age from t_emp where emp_id=?\u0026#34;); //给占位符赋值然后执行sql语句并返回结果。 preparedStatement.setInt(1, 4); ResultSet resultSet = preparedStatement.executeQuery(); Employee employee = null; while (resultSet.next()) { employee = new Employee(); int empId = resultSet.getInt(\u0026#34;emp_id\u0026#34;); String empName = resultSet.getString(\u0026#34;emp_name\u0026#34;); double empSalary = resultSet.getDouble(\u0026#34;emp_salary\u0026#34;); int empAge = resultSet.getInt(\u0026#34;emp_age\u0026#34;); employee.setEmpId(empId); employee.setEmpName(empName); employee.setEmpSalary(empSalary); employee.setEmpAge(empAge); } System.out.println(employee); resultSet.close(); preparedStatement.close(); connection.close(); } } 输出多个结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package com.Chiba.advanced; import com.Chiba.advanced.pojo.Employee; import org.junit.Test; import java.sql.*; import java.util.ArrayList; import java.util.List; public class JDBCAdvanced { @Test public void testORm() throws Exception { //passowrd修改为mysql设置的密码 Connection connection = DriverManager.getConnection(\u0026#34;jdbc:mysql:///jdbcdemo\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;password\u0026#34;); PreparedStatement preparedStatement = connection.prepareStatement(\u0026#34;select emp_id,emp_name,emp_salary,emp_age from t_emp\u0026#34;); ResultSet resultSet = preparedStatement.executeQuery(); Employee employee = null; List\u0026lt;Employee\u0026gt; employeeList = new ArrayList\u0026lt;\u0026gt;(); while (resultSet.next()) { employee =new Employee(); int empId = resultSet.getInt(\u0026#34;emp_id\u0026#34;); String empName = resultSet.getString(\u0026#34;emp_name\u0026#34;); double empSalary = resultSet.getDouble(\u0026#34;emp_salary\u0026#34;); int empAge = resultSet.getInt(\u0026#34;emp_age\u0026#34;); employee.setEmpId(empId); employee.setEmpName(empName); employee.setEmpSalary(empSalary); employee.setEmpAge(empAge); // 将每次循环封装的一个数据的对象存储在集合里 employeeList.add(employee); } for (Employee emp : employeeList) { System.out.println(emp); } resultSet.close(); preparedStatement.close(); connection.close(); } } ","date":"2025-08-25T15:29:50+08:00","image":"https://qyChiba.github.io/Chiba-dev/p/jdbc%E8%BF%9B%E9%98%B6/preview_hu_2d95c60744ae678f.jpg","permalink":"https://qyChiba.github.io/Chiba-dev/p/jdbc%E8%BF%9B%E9%98%B6/","title":"JDBC进阶"},{"content":"JDBC常见问题 1.资源的管理 在使用jdbc的相关资源时，比如Connection、PreparedStatement、ResultSet，使用完毕后，要及时关闭这些资源以释放数据库服务器资源和避免内存泄露等问题。\n2.SQL问题 2.1 SQL语句问题： java.sql.SQLSyntaxErrorException java.sql.SQLSyntaxErrorException：SQL语句错误异常，一般有几种可能：\n1.SQL语句错误，检查SQL语句，建议SQL语句在SQL工具(navicat、dataGrip)中测试后再赋值到java程序中。\n2.连接数据库的URL中，数据库名称编写错误，也会报该异常。\n2.2 SQL语句未设置参数问题 java.sql.SQLException: No value specified for parameter 1 在用预编译SQL语句时，如果有?占位符，要为每一个占位符赋值，否则报该错误。\n2.3 用户名或密码错误 在连接数据库时，如果用户名或密码输入错误，也会报SQLException，容易混淆，看清异常后面原因描述\n2.4通信异常 com.mysql.cj.jdbc.exceptions.CommunicationsException:Communications link failure 在连接数据库URL时，如果IP端口或端口写错了，会报以上异常\n","date":"2025-08-25T14:25:45+08:00","image":"https://qyChiba.github.io/Chiba-dev/p/jdbc%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/preview_hu_d60ce9791cb98501.jpg","permalink":"https://qyChiba.github.io/Chiba-dev/p/jdbc%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","title":"JDBC常见问题"},{"content":"Git 与 Hugo 完整工作流程指南 本指南将详细介绍如何使用 Hugo 和 Git 完成从创建新文件到删除文件的完整工作流程。\n1. 创建新文件 首先，使用 Hugo 命令创建一个新的文章文件。\n1 hugo new content post/TestOne/index.md 这个命令会在 D:\\SoftCache\\TextCache\\HugoCache\\hugo\\dev\\content\\post 目录下创建一个名为 TestOne 的文件夹，并在其中生成一个 index.md 文件。\n2. 将更改添加到 Git 文件创建后，你需要告诉 Git 你的工作目录发生了变化。使用 git add 命令将新创建的文件添加到暂存区。\n1 git add . 这里的 . 代表添加当前目录下的所有更改，包括新创建的文件和对现有文件的修改。\n3. 提交更改 将文件添加到暂存区后，你需要提交这些更改，将其保存为历史记录中的一个版本。\n1 git commit -m \u0026#34;update\u0026#34; -m \u0026quot;update\u0026quot; 后面是本次提交的描述信息，建议写得清晰一些，方便日后查阅。\n4. 推送到远程仓库 提交后，你的更改只保存在本地。要将这些更改同步到 GitHub 等远程仓库，你需要使用 git push 命令。\n1 git push 执行这条命令后，你的本地修改就会被上传到远程仓库，这样其他人也能看到你的最新版本了。\n5. 删除文件 如果需要删除之前创建的文件，最常见且最安全的做法是使用 git rm 命令。\n1 git rm D:\\SoftCache\\TextCache\\HugoCache\\hugo\\dev\\content\\post\\TestOne\\index.md git rm 命令不仅会删除工作目录中的文件，还会同时将这个删除操作标记为暂存状态，为下一次提交做好准备。\n6. 提交删除并推送到远程仓库 删除操作也需要被提交到 Git 历史中。\n提交删除操作： 1 git commit -m \u0026#34;delete TestOne\u0026#34; 推送到远程仓库： 1 git push 完成这些步骤后，TestOne 文件就会从你的本地仓库和远程仓库中都消失了。 ","date":"2025-08-24T16:43:14+08:00","permalink":"https://qyChiba.github.io/Chiba-dev/p/git%E4%B8%8Ehugo%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/","title":"Git与Hugo工作流程"},{"content":"JDBC-入门到高级 一、JDBC搭建： 1.准备数据库\n2.下载连接驱动jar包。\n3.创建Java项目，在项目下创建lib文件夹内，将下载完成的jar包复制到文件夹里面。\n4.选中lib文件夹右键\u0026ndash;\u0026gt;Add as Library(添加为库)，与项目集成。\n5.编写代码\n完整代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package com.Chiba.base; import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.Statement; public class JDBCQuick { public static \u0026lt;connection\u0026gt; void main(String[] args) throws Exception { // 1.注册驱动 Class.forName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); // 2.获取连接对象 String url = \u0026#34;jdbc:mysql://localhost:3306/jdbcdemo\u0026#34;; String username = \u0026#34;root\u0026#34;; //password修改成自己设置的mysql密码 String password = \u0026#34;password\u0026#34;; Connection connection = DriverManager.getConnection(url, username, password); // 3.获取执行sql语句的对象 --\u0026gt;把sql语句发送给mysql的对象 Statement statement = connection.createStatement(); // 4.编写SQL语句，并执行,接受返回的结果集 String sql = \u0026#34;select emp_id,emp_name,emp_salary,emp_age from t_emp;\u0026#34;; ResultSet resultSet = statement.executeQuery(sql); // 5.处理结果，遍历result结果集 while (resultSet.next()) { int empId = resultSet.getInt(\u0026#34;emp_id\u0026#34;); String empName = resultSet.getString(\u0026#34;emp_name\u0026#34;); double empSalary = resultSet.getDouble(\u0026#34;emp_salary\u0026#34;); int empAge = resultSet.getInt(\u0026#34;emp_age\u0026#34;); System.out.println(empId + \u0026#34;\\t\u0026#34; + empName + \u0026#34;\\t\u0026#34; + empSalary + \u0026#34;\\t\u0026#34; + empAge); } // 6.释放资源(遵循先开后关原则)--\u0026gt;目前有connection、statement、resultSet三个资源 resultSet.close(); statement.close(); connection.close(); } } 二、核心API理解 2.1注册驱动 1 Class forname(\u0026#34;com.mysql.cj.jdbc.driver\u0026#34;); 注册驱动是为了和数据库通信，加载驱动程序的目的是为了注册驱动程序，使得JDBC API能够识别并且与特定的数据库进行交互。\n从JDK6开始就不需要写Class forname()来加载JDBC驱动程序，只要在类路径中集成了对应的jar文件，会自动在初始化时注册驱动程序。\n2.2 Connection Connection接口是JDBC API的重要接口，用于建立与数据库通信通道，只要Connection不为空，就代表一次与数据库连接。\n在建立连接时，需要指定数据库URL、用户名、密码。\nURL：jdbc:mysql://localhost:3306/jdbcdemo\njdbc:mysql//IP地址:端口号/数据库名称?参数键值对1\u0026amp;参数键值对2\njdbc:mysql://是固定的 localhost对应着IP地址，这里不是固定的，如果说是买了云服务，那么就要写云服务厂商的数据库IP地址 3306对应的端口号，一般默认的是3306。 斜线分割后对应的jdbcdemo对应的是数据库名称，就是当前要操作那个数据库 如果还有参数要设置添加这时候就不要用/了，要用?隔开，然后写key=value 注：如果你用的是自己的IP地址(localhost)和默认端口号(3306)那么这时候url就可以写：com:mysql:///jdbcdemo\nConnection接口还负责管理事务，Connection接口提供了commit和rollback方法，用于提交事务和回滚事务。\n可以创建Statement对象，用于执行SQL语句并与数据库进行交互。\n在用jdbc技术时，必须先获取connection对象(如果没有获取Connection对象后续的操作不复存在)，Connection也代表的是一次链接，在使用完毕后，要释放资源，避免资源占用浪费和泄露。\n2.3 Statement Statement接口用于执行SQL语句并与数据库进行交互。它是JDBC API中的重要接口。通过Statement对象，可以向数据库发送SQL语句并获取执行结果。\n结果可以是一个或多个结果。\n增删改：受影响行数单个数据。 查询：单行单列、多行多列、单行多列等结果。 Statement接口在执行SQL语句时，会产生SQL注入攻击问题：\n当使用Statement执行动态构建的SQL查询时，往往需要将查询条件与SQL语句拼接在一起，直接将参数和SQL语句一并生成，让SQL的查询条件始终为true得到结果。 2.4PreparedStatement PreparedStatement是Statement接口的子接口，用于执行预编译的SQL查询，作用如下： 预编译SQL语句：在创建PreparedStatement时，就会预编译SQL，也就是SQL语句已经固定。 防止SQL注入：PreparedStatement支持参数化查询，将数据作为参数传递到SQL语句中，采用？占位符的方式，将传入的参数用一对单引号(\u0026rsquo;\u0026rsquo;)包裹起来，无论传递什么都作为值，有效防止传入关键字或值导致SQL注入问题 性能提升：PreparedStatement是预编译SQL语句，同一SQL语句多次执行的情况下，可以复用，不必每次重新编译和解析。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package com.Chiba.base; import java.sql.*; import java.util.Scanner; public class JDBCPrepared { public static void main(String[] args) throws Exception { String url = \u0026#34;jdbc:mysql://localhost:3306/jdbcdemo\u0026#34;; String username = \u0026#34;root\u0026#34;; //password修改成自己设置mysql的密码 String password = \u0026#34;password\u0026#34;; //password修改为mysql设置的密码 Connection connection = DriverManager.getConnection(\u0026#34;jdbc:mysql://localhost:3306/jdbcdemo\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;password\u0026#34;); PreparedStatement preparedstatement = connection.prepareStatement(\u0026#34;select emp_id,emp_name,emp_salary,emp_age from t_emp where emp_name=?\u0026#34;); Scanner sc = new Scanner(System.in); System.out.println(\u0026#34;请输入姓名\u0026#34;); String name = sc.nextLine(); preparedstatement.setString(1,name); ResultSet resultSet = preparedstatement.executeQuery(); while (resultSet.next()) { int empId = resultSet.getInt(\u0026#34;emp_id\u0026#34;); String empName = resultSet.getString(\u0026#34;emp_name\u0026#34;); double empSalary = resultSet.getDouble(\u0026#34;emp_salary\u0026#34;); int empAge = resultSet.getInt(\u0026#34;emp_age\u0026#34;); System.out.println(empId + \u0026#34;\\t\u0026#34; + empName + \u0026#34;\\t\u0026#34; + empSalary + \u0026#34;\\t\u0026#34; + empAge); } resultSet.close(); preparedstatement.close(); connection.close(); } } 1 select emp_id,emp_name,emp_salary,emp_age from t_emp where emp_name=?； 如果用sql注入的话就是输入：abc\u0026rsquo; or \u0026lsquo;1\u0026rsquo;=\u0026lsquo;1，这时候abc' or '1'='1就会代替问号并且加上两边加上单引号：\n1 select emp_id,emp_name,emp_salary,emp_age from t_emp where emp_name=\u0026#39;abc\u0026#39; or \u0026#39;1\u0026#39;=\u0026#39;1\u0026#39;； 这是后看着虽然和用Statement时候注入的形式一样，但是PreparedStatement会在他们中间加上转义字符，使得他们变成普通的值：\n1 select emp_id,emp_name,emp_salary,emp_age from t_emp where emp_name=\u0026#39;abc\\\u0026#39; or \\\u0026#39;1\\\u0026#39;=\\\u0026#39;1\u0026#39;； **总结：**在实际应用中，不要使用Statement类，因为它有sql注入的漏洞，反而我们要统一的使用Statement的子类PreparedStatement类，它不仅可以防止sql注入还可以提高性能，因为它是预编译的,可以复用不需要每次都编译。总而言之，使用``PreparedStatement`更安全、更高效。\n2.5ResultSet ResultSet是JDBC API中的一个接口，用于从数据库中执行查询语句所返回的结果集，它提供了一种用于遍历和访问查询结果的方式。 遍历结果：ResultSet可以使用**next()**方法将游标移动到结果集的下一行，逐行遍历数据库查询的结果，返回值为boolean类型，true表示有下一行的结果，false表示没有。 获取单列结果：可以通过getXxx的方法获取单列的数据，该方法为重载方法 ，支持索引和列名进行获取。 专业术语\u0026ndash;ORM：\nJDBC全流程：注册驱动\u0026mdash;\u0026gt;获取连接\u0026mdash;\u0026gt;预编译获取PreparedStatement对象\u0026mdash;\u0026gt;编写并执行sql语句\u0026mdash;\u0026gt;遍历结果集\u0026mdash;\u0026gt;资源释放\n案例\u0026mdash;\u0026gt;CURD 查询\u0026ndash;\u0026gt;单行单列： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package com.Chiba.base; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; public class TestDemo { public static void main(String[] args) throws Exception { // 1.驱动注册 Class.forName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); // 2.获取连接---\u0026gt;passowrd修改为mysql设置的密码 Connection connection = DriverManager.getConnection(\u0026#34;jdbc:mysql://localhost:3306/jdbcdemo\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;password\u0026#34;); // 3.预编译PreparedStatement对象 PreparedStatement preparStatement = connection.prepareStatement(\u0026#34;select count(*) as count from t_emp\u0026#34;); // 4.获取返回值 ResultSet resultSet = preparStatement.executeQuery(); // 5.遍历值 while(resultSet.next()){ int count=resultSet.getInt(\u0026#34;count\u0026#34;); System.out.println(count); } resultSet.close(); preparStatement.close(); connection.close(); } } 查询\u0026ndash;\u0026gt;单行多列： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package com.Chiba.base; import org.junit.Test; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; public class JDBCOperation { @Test public void testQuerySingleRow() throws Exception { //注册驱动 Class.forName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); //获取连接(url、name、password)---\u0026gt;passowrd修改为mysql设置的密码 Connection connection = DriverManager.getConnection(\u0026#34;jdbc:mysql://localhost:3306/jdbcdemo\u0026#34;,\u0026#34;root\u0026#34;,\u0026#34;password\u0026#34;); //预编译获取preparedStatement对象 PreparedStatement preparedStatement=connection.prepareStatement(\u0026#34;select emp_id,emp_name,emp_salary,emp_age from t_emp where emp_id=?\u0026#34;); //给占位符赋值然后执行并获取结果集 preparedStatement.setInt(1,4); ResultSet resultSet=preparedStatement.executeQuery(); //结果集遍历 while(resultSet.next()){ int empId=resultSet.getInt(\u0026#34;emp_id\u0026#34;); String empName=resultSet.getString(\u0026#34;emp_name\u0026#34;); Double empSalary=resultSet.getdouble(\u0026#34;emp_salary\u0026#34;); int empAge=resultSet.getInt(\u0026#34;emp_age\u0026#34;); System.out.println(empId+\u0026#34;\\t\u0026#34;+empName+\u0026#34;\\t\u0026#34;+empSalary+\u0026#34;\\t\u0026#34;+empAge); } //关闭资源 resultSet.close(); preparedStatement.close(); connection.close(); } } 查询\u0026ndash;\u0026gt;多行多列: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package com.Chiba.base; import org.junit.Test; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; public class JDBCOperation { @Test public void testQueryMoreRow() throws Exception { // 1.注册驱动 Class.forName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); // 2.获取连接(url、name、password)---\u0026gt;passowrd修改为mysql设置的密码 Connection connection = DriverManager.getConnection(\u0026#34;jdbc:mysql:///jdbcdemo\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;password\u0026#34;); // 3.预编译获得preparedStatement对象 PreparedStatement preparedStatement = connection.prepareStatement(\u0026#34;select emp_id,emp_name,emp_salary,emp_age from t_emp where emp_age\u0026gt;?\u0026#34;); // 4.为占位符赋值才能执行sql preparedStatement.setInt(1, 25); ResultSet resultSet = preparedStatement.executeQuery(); // 5.遍历 while (resultSet.next()) { int empId = resultSet.getInt(\u0026#34;emp_id\u0026#34;); String empName = resultSet.getString(\u0026#34;emp_name\u0026#34;); double empSalary = resultSet.getDouble(\u0026#34;emp_salary\u0026#34;); int empAge = resultSet.getInt(\u0026#34;emp_age\u0026#34;); System.out.println(empId + \u0026#34;\\t\u0026#34; + empName + \u0026#34;\\t\u0026#34; + empSalary + \u0026#34;\\t\u0026#34; + empAge); } // 6.资源释放 resultSet.close(); preparedStatement.close(); connection.close(); } } 增加数据: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package com.Chiba.base; import org.junit.Test; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; public class JDBCOperation { @Test public void testInsert() throws Exception { // 1.注册驱动 Class.forName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); // 2.获取连接(url、name、password)--\u0026gt;passowrd修改为mysql设置的密码 Connection connection = DriverManager.getConnection(\u0026#34;jdbc:mysql:///jdbcdemo\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;password\u0026#34;); // 3.预编译获取preparedStatement对象 PreparedStatement preparedStatement = connection.prepareStatement(\u0026#34;insert into t_emp(emp_name,emp_salary,emp_age)values(?,?,?)\u0026#34;); preparedStatement.setString(1, \u0026#34;Mike\u0026#34;); preparedStatement.setDouble(2, 9999.99); preparedStatement.setInt(3, 25); int res = preparedStatement.executeUpdate(); // 根据受影响行数判断true或false； if (res \u0026gt; 0) { System.out.println(\u0026#34;True\u0026#34;); } else { System.out.println(\u0026#34;False\u0026#34;); } preparedStatement.close(); connection.close(); } } 更改数据: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package com.Chiba.base; import org.junit.Test; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; public class JDBCOperation { @Test public void testUpdate() throws Exception { Class.forName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); //passowrd修改为mysql设置的密码 Connection connection = DriverManager.getConnection(\u0026#34;jdbc:mysql:///jdbcdemo\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;password\u0026#34;); PreparedStatement preparedStatement = connection.prepareStatement(\u0026#34; update t_emp set emp_salary=? where emp_id=?;\u0026#34;); preparedStatement.setDouble(1, 10000); preparedStatement.setInt(2, 6); int res = preparedStatement.executeUpdate(); if (res \u0026gt; 0) { System.out.println(\u0026#34;True\u0026#34;); } else { System.out.println(\u0026#34;False\u0026#34;); } // 关闭资源 preparedStatement.close(); connection.close(); } } 删除数据： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package com.Chiba.base; import org.junit.Test; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; public class JDBCOperation { @Test public void testDelete() throws Exception { // 注册驱动 Class.forName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); // 获取连接 ---\u0026gt;passowrd修改为mysql设置的密码 Connection connection = DriverManager.getConnection(\u0026#34;jdbc:mysql://localhost:3306/jdbcdemo\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;password\u0026#34;); // 预编译获取preparedStatement对象 PreparedStatement preparedStatement = connection.prepareStatement(\u0026#34;delete from t_emp where emp_id=?\u0026#34;); // 给占位符赋值，执行sql语句获取结果集 preparedStatement.setInt(1, 7); int result = preparedStatement.executeUpdate(); if (result \u0026gt; 0) { System.out.println(\u0026#34;True\u0026#34;); } else { System.out.println(\u0026#34;False\u0026#34;); } // 关闭资源 preparedStatement.close(); connection.close(); } } 在执行sql返回结果的时候：\n如果是查询就用executeQuery()\n如果是增删改就用executeUpdate()\n","date":"2025-08-23T23:01:38+08:00","image":"https://qyChiba.github.io/Chiba-dev/p/jdbc-%E5%85%A5%E9%97%A8%E5%88%B0%E9%AB%98%E7%BA%A7/MeiGuiHua_hu_469f0924edc03d5b.png","permalink":"https://qyChiba.github.io/Chiba-dev/p/jdbc-%E5%85%A5%E9%97%A8%E5%88%B0%E9%AB%98%E7%BA%A7/","title":"JDBC-入门到高级"}]